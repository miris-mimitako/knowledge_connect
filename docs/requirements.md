# 要件定義書

## プロジェクト概要

本プロジェクトは、Obsidian用のコミュニティプラグインです。AIを活用した機能を提供し、ユーザーの知識管理と情報処理を支援します。

## 機能要件

### 1. AIチャット機能

**概要**
- AIと対話形式で会話できるチャット機能を提供します。

**詳細要件**
- チャットインターフェースを表示するUIを提供する
- ユーザーがテキスト入力でAIに質問や指示を送信できる
- AIからの応答をリアルタイムで表示する
- 会話履歴を保持し、過去のやり取りを参照できる
- チャットウィンドウを開閉できる
- 会話履歴をクリアできる機能を提供する
- チャット履歴から新しいページを作成できる機能を提供する
  - 問い合わせと返答がそのままページを構成する
  - 保存先は設定で指定した場所がデフォルト
  - 実行前にユーザーが保存先とファイル名を指定できる
- AIが要約してページを作成する機能を提供する
  - チャットのモデルをデフォルトとして使用
  - モデルを選択したうえで要約を実行
  - 保存先は設定で指定した場所がデフォルト
  - 実行前にユーザーが保存先とファイル名を指定できる

**UI要件**
- View（サイドパネル）として表示
- ObsidianのUIデザインに統合されたチャットインターフェース
- 入力フィールドと送信ボタン
- 会話履歴の表示エリア
- チャット履歴からページ作成ボタン
- AI要約でページ作成ボタン（モデル選択付き）
- 保存先選択ダイアログ

### 2. AI要約機能

**概要**
- 選択したテキストやファイルの内容をAIに要約してもらう機能を提供します。

**詳細要件**
- エディタで選択したテキストを要約できる
- 現在開いているファイル全体を要約できる
- 要約結果を表示するUIを提供する
- 要約結果をクリップボードにコピーできる
- 要約結果を現在のファイルに挿入できる
- 要約の詳細度（簡潔/標準/詳細）を選択できるオプションを提供する

**UI要件**
- コマンドパレットから実行可能なコマンド
- 要約結果を表示するView（サイドパネル）
- 要約オプションを設定するUI
- 要約結果をクリップボードにコピー、ファイルに挿入するボタン

### 3. AI Web検索機能

**概要**
- AIにWeb検索を依頼し、検索結果を取得・表示する機能を提供します。

**詳細要件**
- ユーザーが検索クエリを入力できる
- AIがWeb検索を実行し、関連情報を収集する
- 検索結果を構造化して表示する
- 検索結果のソース（URL）を表示する
- 検索結果をクリップボードにコピーできる
- 検索結果をファイルに保存できる
- 検索履歴を保持する（オプション）

**UI要件**
- View（サイドパネル）として表示
- 検索クエリ入力フィールド
- 検索結果を表示するエリア
- 検索結果のソースリンクを表示
- 検索履歴を表示する機能（オプション）

### 4. AI出力データ保存機能

**概要**
- AIが生成したデータ（チャット履歴、要約結果、検索結果など）を任意のフォルダやファイルに保存する機能を提供します。

**詳細要件**
- 保存先のフォルダを選択できる
- ファイル名を指定できる
- 保存形式を選択できる（Markdown、テキスト、JSONなど）
- 既存ファイルに追記するか、新規ファイルを作成するかを選択できる
- 保存前にプレビューを表示できる
- 保存成功/失敗の通知を表示する
- デフォルトの保存先フォルダを設定できる

**UI要件**
- 保存先選択ダイアログ
- ファイル名入力フィールド
- 保存形式選択ドロップダウン
- 保存オプション（新規/追記）の選択UI

### 5. コンテキストメニューからのAI問い合わせ機能

**概要**
- エディタで選択したテキスト（単語、行、段落など）を右クリックメニューから直接AIに問い合わせることができる機能を提供します。

**詳細要件**
- エディタでテキストを選択した状態で右クリックすると、コンテキストメニューにAI問い合わせオプションを表示する
- 選択したテキストを自動的にAIへの質問として送信する
- 選択したテキストに対して、以下のような問い合わせアクションを提供する：
  - 「この単語について説明する」
  - 「この内容を要約する」
  - 「この内容について質問する」
  - 「この内容を翻訳する」（オプション）
  - 「この内容を改善する」（オプション）
- AIの応答をView（サイドパネル）に表示する
- 応答結果をクリップボードにコピーできる
- 応答結果を現在のファイルに挿入できる
- 応答結果を別ファイルに保存できる
- テキストが選択されていない場合は、コンテキストメニューにAI問い合わせオプションを表示しない（または無効化する）

**UI要件**
- Obsidianの標準コンテキストメニューに統合されたメニュー項目
- 問い合わせタイプを選択するサブメニュー（オプション）
- AI応答を表示するView（サイドパネル）
- 応答に対するアクションボタン（コピー、挿入、保存など）

**技術要件**
- ObsidianのコンテキストメニューAPIを使用してメニュー項目を追加する
- エディタの選択状態を検出し、選択テキストを取得する
- 選択テキストが空の場合はメニュー項目を非表示または無効化する

### 6. ファイル検索機能（キーワード検索・ベクトル検索・ハイブリッド検索）

**概要**
- Obsidian内のファイルを検索する機能を提供します。キーワード検索、ベクトル検索、ハイブリッド検索の3つの検索方式をサポートします。

**詳細要件**

#### 6.1 検索方式

**キーワード検索**
- スペース区切りのキーワードで検索可能
- 複数キーワードはAND検索とOR検索の両方をサポート
- AND検索の結果を優先表示し、それ以外は日付順で表示
- キーワードヒット部分をハイライト表示
- 日本語テキストの単語分割には`Intl.Segmenter`（ブラウザ標準API）を使用
  - Obsidianは日本語解析の公式APIを提供していないため、標準Web APIを利用
  - 日本語の単語境界を正確に検出し、検索精度を向上

**ベクトル検索**
- セマンティック検索（意味的類似度検索）を提供
- 類似度順で結果を表示
- 検索結果件数は10件～100件までユーザーが任意に選択可能
- デフォルトは10件

**ハイブリッド検索**
- キーワード検索とベクトル検索の結果をReciprocal Rank Fusion (RRF) アルゴリズムで統合
- 両方の検索方式の利点を組み合わせた検索結果を提供
- **RRFの実装詳細**:
  - kパラメータ: 60で固定（論文の推奨値、Elasticsearchのデフォルト）
  - 重み付け: 1:1（重み付けなし）で実装
  - スコア正規化: 不要（順位だけ取得するため、BM25スコアとコサイン類似度を混ぜても問題なし）
  - 計算式: $RRFscore(d) = \sum_{r \in R} \frac{1}{k + rank(d)}$
  - 将来的な拡張: クエリ分析に基づく自動調整ロジックを検討（型番っぽいクエリはキーワード検索を重視、文章クエリはベクトル検索を重視）

#### 6.2 検索結果表示

- **レイアウト**: 幅広のカード（実質的なリストビュー）で、視線の移動が縦方向だけで済む設計
- **カードの構成**:
  - **ヘッダー行（1行目）**:
    - 左側: ファイル名（太字、`font-size: 1.1em`）
    - 中央: パンくずリスト（Short path）または親フォルダ名（`font-size: 0.8em`、色: `#888`）
      - 例: `.../ProjectA/Design/`（階層が深い場合）
    - 右側: 最終更新日（`font-size: 0.8em`、色: `#888`）
  - **ボディ行（2-4行目）**: ファイル内容のプレビュー（3行固定、CSSの`line-clamp`を使用）
- **スタイリング**:
  - 親コンテナにパディング（`padding: 0 8px;`）を設定し、カード自体は`width: 100%;`
  - カード全体に`padding: 12px;`を設定
  - カード間に`border-bottom: 1px solid #e0e0e0;`で区切り線を表示
  - `cursor: pointer;`でクリック可能であることを示す
- **インタラクション**:
  - カード全体がクリック可能
  - 2画面構成の場合：左側で閲覧中なら右側で開く
  - それ以外：別タブで開く
  - マウスオーバー時に背景色を変更してクリック可能であることを示す（オプション）

#### 6.3 ベクトル化処理

**ベクトル化のタイミング**
- 新しいページが生成されたとき（High優先度）
- ページが閉じられたとき（High優先度）
- プラグイン起動時の全ファイルスキャン（Low優先度）
- 即座に開始せず、キューを生成してタスク管理で順次実行
- ベクトル化が完了したらキューから削除
- ベクトル化済みのマークをページの右上に表示

**キューの管理**
- 同時実行数：最大2スレッド（FIFO方式）
- 優先度：High（即時処理）とLow（バックグラウンド）の2段階
- エラーハンドリング：Exponential Backoffでリトライ、最大3〜5回
- 永続化：プラグイン再起動時にキューを復元（`data.json`またはIndexedDB）
- 進捗表示：ステータスバー（右下）に「Vectorizing: 5/100」形式で表示

**ベクトル化対象のディレクトリ**
- **初期設定**: すべての領域（ルートディレクトリ全体）を選択
- **除外機能**: ユーザーが明示的に除外フォルダを指定可能（Deny List方式）
  - コスト削減と検索精度向上のため、`Templates/`, `Daily Notes/`（の古いログ）, `Archives/`などのノイズになるフォルダを除外
- **デフォルト強制除外**: 隠しファイル・フォルダ（`.`で始まるもの）をデフォルトで強制除外
  - 例: `.obsidian`（Obsidianの設定フォルダ）など
- **UI**: 独自モーダルUIでチェックボックス付きのツリービューを提供
  - 3値ステータス（対象/除外/継承）を持つツリーUI
- **保存**: 設定（パス情報）は`data.json`に保存、インデックス（ベクトルデータ）はIndexedDB等に保存
- **フォルダ名変更への追従**: `vault.on('rename')`イベントを監視し、設定ファイル内のパス文字列も自動的に書き換える（または存在しないパスは警告を表示）
- **自動追従**: 新しいディレクトリがルートディレクトリに追加された場合も自動的に追従

**ベクトル化モデル**
- 使用可能なモデル：
  - "qwen/qwen3-embedding-8b"
  - "google/gemini-embedding-001"
  - "openai/text-embedding-ada-002"
- OpenRouter APIでアクセス
- モデルはユーザーが最初に設定時に決定
- **モデル変更時の警告UI**:
  - **インパクト分析モーダル**を表示（即座に変更しない）
    - 変更の影響を可視化（精度、処理速度、整合性など）
    - 既存の検索用インデックス件数、再計算の推定コスト、推定所要時間を表示
  - **破壊的変更の明示**: チェックボックスで「既存のインデックスデータが削除されることを理解しました」を確認
  - **既存データの削除戦略**: スナップショット保持（推奨）、遅延削除、完全置換の3パターンから選択
  - **段階的な移行オプション**: オンデマンド移行、バックグラウンド移行（推奨）、メンテナンスモードから選択
  - 「変更して再計算を開始」ボタンが活性化（Active）するまで変更を実行しない
- ベクトルの次元数：デフォルト1536次元（モデルによって異なる場合はモデルの次元数を使用）

#### 6.4 データベース

- Oramaを使用して検索インデックスとベクトルデータを保存
- キーワード検索用のインデックスとベクトル検索用のベクトルデータを管理
- **データベースの永続化**
  - **保存形式**: バイナリ形式（dpack / Protocol Buffers等）を使用（JSONより効率的）
  - **保存場所**: `.obsidian/plugins/プラグインID/index-data.bin`
  - **実装**: OramaのPersistence Plugin（`@orama/plugin-data-persistence`）を使用
  - **更新タイミング**: ファイル保存時の差分更新（デバウンス付き）
  - **復元**: インデックス破損時は「Rebuild Index」機能で再構築可能
- **最適化**
  - データベースサイズの見積もり：`ノート数 × チャンク数 × 次元数 × 4バイト(Float32)`
  - 次元削減や量子化（Quantization）を検討してメモリ使用量を抑制
  - 数万ノート環境ではメモリ使用量に注意が必要

**UI要件**
- View（サイドパネル）として表示
- 検索方式を選択するタブまたはラジオボタン（キーワード/ベクトル/ハイブリッド）
- 検索クエリ入力フィールド
- ベクトル検索の場合は結果件数選択スライダー（10～100件）
- **検索結果をカード形式で表示するエリア**
  - 幅広のカード（実質的なリストビュー）で、視線の移動が縦方向だけで済む設計
  - 親コンテナにパディング（`padding: 0 8px;`）を設定し、カード自体は`width: 100%;`
  - カード全体に`padding: 12px;`を設定
  - カード間に`border-bottom: 1px solid #e0e0e0;`で区切り線を表示
  - `cursor: pointer;`でクリック可能であることを示す
- **各カードの構成**
  - **ヘッダー行（1行目）**: 
    - 左側: ファイル名（太字、`font-size: 1.1em`）
    - 中央: パンくずリスト（Short path）または親フォルダ名（`font-size: 0.8em`、色: `#888`）
    - 右側: 最終更新日（`font-size: 0.8em`、色: `#888`）
  - **ボディ行（2-4行目）**: ファイル内容のプレビュー（3行固定、CSSの`line-clamp`を使用）
- キーワードハイライト表示
- ベクトル化済みマーク（ページ右上）
- **ベクトル化対象ディレクトリの設定UI**
  - 独自モーダルUIでチェックボックス付きのツリービューを提供
  - 3値ステータス（対象/除外/継承）を持つツリーUI
  - 初期設定は全域（ルートディレクトリ全体）
  - 除外フォルダを明示的に指定可能（Deny List方式）
  - デフォルト強制除外リスト（隠しファイル・フォルダ）を表示
  - フォルダ名変更への追従機能
- **ベクトル化モデルの設定UI（初回設定時と変更時）**
  - モデル選択のプルダウン
  - **モデル変更時の警告ダイアログ**:
    - インパクト分析モーダル（変更の影響を可視化）
    - コスト・時間の見積もり表示（既存インデックス件数、推定コスト、推定所要時間）
    - リスク確認のチェックボックス
    - 既存データの削除戦略選択（スナップショット保持、遅延削除、完全置換）
    - 段階的な移行オプション選択（オンデマンド移行、バックグラウンド移行、メンテナンスモード）
    - 「変更して再計算を開始」ボタン（確認後に活性化）
- **インデックス管理UI**
  - 「Rebuild Index」ボタン（設定画面または専用Viewに配置）
  - 失敗したファイルの一覧表示（設定画面/専用View）
  - 手動での再実行ボタン

**技術要件**
- 検索処理はWeb Workerで実行（UIをブロックしない）
- Oramaライブラリを使用したインデックス管理
- OpenRouter APIを使用したベクトル化処理
- ベクトル化タスクのキュー管理システム
- **ファイル変更の監視と自動インデックス更新**
  - `this.app.vault.on()`を利用して`modify`, `create`, `delete`, `rename`イベントを監視
  - デバウンス（2〜5秒）とキューを組み合わせて非同期処理
  - ファイル削除時は即座にインデックスから削除
- Obsidianの日本語解析機能の統合
- **RRFアルゴリズムの実装**
  - kパラメータ: 60で固定
  - 重み付け: 1:1（重み付けなし）で実装
  - スコア正規化: 不要（順位だけ取得する）
  - 各検索エンジンから`TOP N`件のIDと順位だけを取得して計算
  - 将来的な拡張: クエリ分析に基づく自動調整ロジックを検討
- **ベクトル化済みマークの実装**
  - Obsidian APIの`view.addAction`を使用してエディタ右上にアイコンを追加
  - CSSクラスを付与して色（緑色など）で状態を表現
  - `active-leaf-change`や`metadata-change`イベントをフックして自動更新
  - 判定ロジック: フロントマターまたはDB上のIDリストと照合
- **ディレクトリ指定UIの実装**
  - 独自モーダルUI（ReactやSvelte等）でチェックボックス付きのツリービューを実装
  - 設定（パス情報）は`data.json`に保存（`excludedFolders: ["Templates", "System/Logs"]`形式）
  - `vault.on('rename')`イベントを監視してフォルダ名変更に追従
  - デフォルト強制除外リスト（隠しファイル・フォルダ）を実装
- **Web Workerの実装**
  - Oramaのインスタンス（インデックスデータ）はWorker内だけで保持
  - OpenRouter API呼び出しはWorker内で実行（ストリーミング対応）
  - メインスレッドからは「検索クエリ」や「追加したいドキュメント」だけを送り、Workerからは「検索結果（IDやスニペット）」だけを受け取る
  - データ転送の最適化：必要なデータだけを送る（Oramaの`returning`オプションを活用）
  - イベントリスナーの管理：Comlinkなどのライブラリを使うか、アクションベースで分岐
- ベクトルデータの永続化（プラグインデータディレクトリ）
- **エラーハンドリングとリカバリー**
  - 部分失敗の許容：特定ファイルで失敗してもループを止めず、次のファイルへ進む
  - 失敗ファイルリストを内部ステートに保持し、設定画面で表示
  - DB破損時は「インデックスの全再構築（Rebuild）」機能を提供
  - ステータスバーに進捗アイコンを表示、致命的なエラー以外でNoticeを連発しない
- **パフォーマンス最適化**
  - インデックスの段階的ロード：永続化データの読み込みは非同期で行い、「準備中」ステータスを表示
  - 検索結果のページネーション：トップ10〜20件のみ表示、Infinite Scrollまたは「もっと見る」ボタン
  - キャッシュ戦略：ベクトルデータをIndexedDBに永続化、`mtime`をハッシュとして保存し変更がないファイルはスキップ
- **モバイル対応**
  - Web Workerは必須（メインスレッドでベクトル計算を行うとアプリがキルされる可能性）
  - モバイルでは量子化された軽量モデルを使用、またはPCで生成したインデックスを同期して「検索（閲覧）のみ」許可
  - モバイル時はインデックス件数に上限を設けるなどのガードが必要
- **依存関係の管理**
  - Oramaのバージョンを固定（`^`ではなく厳密指定）、アップデート時は入念なテスト
  - モデルファイルはバンドルに含めず、初回実行時にCDNからダウンロードしてキャッシュ
  - ライセンス確認：Orama（Apache 2.0）とEmbeddingモデルのライセンスをREADMEに記載

## 非機能要件

### パフォーマンス
- チャット応答時間は可能な限り短くする（目標: 3秒以内）
- 大量のテキスト要約時もUIがフリーズしないようにする
- Web検索結果の取得は非同期で実行し、UIをブロックしない
- 検索処理はWeb Workerで実行し、UIをブロックしない
- ベクトル化処理はキュー管理で順次実行し、システムリソースを適切に管理する
  - 同時実行数は最大2スレッド（FIFO方式）でAPIレート制限を回避
  - ネットワーク帯域を占有せず、UIへの影響を最小化
- 大量のファイルがある場合でも検索パフォーマンスを維持する
- **データベースのパフォーマンス**
  - バイナリ形式（dpack等）を使用してロード時間を短縮
  - インデックスの更新はデバウンス付きで実行し、リアルタイム更新を避ける
  - データベースサイズの見積もり：`ノート数 × チャンク数 × 次元数 × 4バイト(Float32)`
  - 数万ノート環境ではメモリ使用量に注意し、次元削減や量子化を検討

### セキュリティ・プライバシー
- APIキーなどの認証情報は安全に保存する（Obsidianの設定システムを使用）
- ユーザーデータを外部に送信する場合は、明示的な同意を得る
- 送信されるデータの内容をユーザーに明示する

### ユーザビリティ
- Obsidianの既存UIデザインと調和する
- 直感的な操作ができる
- エラーメッセージは分かりやすく日本語で表示する
- 設定項目には適切なデフォルト値を設定する

### 互換性
- Obsidianの最新バージョンと互換性を保つ
- モバイル版Obsidianでも動作する（可能な限り）

## 技術要件

### AI API統合
- 使用するAIサービス（OpenAI、Claude、その他）を設定で選択できる
- APIキーの設定機能を提供する
- レート制限やエラーハンドリングを適切に実装する

### データ保存
- ObsidianのファイルシステムAPIを使用してファイルを保存する
- 保存先のパス検証を行う
- ファイル名の無効文字を処理する
- Oramaデータベースの永続化（プラグインデータディレクトリ）
  - **保存形式**: バイナリ形式（dpack / Protocol Buffers等）を使用
  - **保存場所**: `.obsidian/plugins/プラグインID/index-data.bin`
  - **実装**: OramaのPersistence Plugin（`@orama/plugin-data-persistence`）を使用
- ベクトルデータの永続化（プラグインデータディレクトリ）
  - ベクトルデータはキャッシュとして扱い、Markdownから再生成可能
  - 同期ツール（Obsidian Sync / iCloud / Dropbox等）の対象外にする設定を推奨
  - インデックス破損時は「Rebuild Index」機能で再構築可能

### 日本語解析
- **実装方法**: `Intl.Segmenter`（ブラウザ標準API）を使用
  - Obsidianは日本語解析の公式APIを提供していないため、標準Web APIを利用
  - キーワード検索の単語分割とハイライト表示に使用
  - 品詞情報が必要な場合は外部ライブラリ（TinySegmenter、Kuromoji.js）を検討
- **パフォーマンス**: ライブラリ不要で高速、メモリ消費が小さい
- **互換性**: Obsidianのデスクトップ・モバイル版（iOS/Android）のWebViewで利用可能

### ベクトル化キューの実装
- **同時実行数**: 最大2スレッド（FIFO方式）
- **優先度管理**: High（即時処理）とLow（バックグラウンド）の2段階
- **エラーハンドリング**: Exponential Backoff（指数バックオフ）でリトライ、最大3〜5回
- **永続化**: 小規模は`data.json`、大規模はIndexedDB（`localforage`推奨）
- **進捗表示**: ステータスバー（右下）に「Vectorizing: 5/100」形式で表示、クリックで詳細モーダル
- **実装ライブラリ**: セマフォまたは`p-limit`ライブラリを使用

### UI実装
- 各機能はObsidianのView APIを使用してサイドパネルとして実装する
- Viewはタブとして表示され、複数のViewを切り替えられる
- Viewの状態（会話履歴、検索履歴など）は適切に保持する
- モーダルは将来的な拡張として検討する（必要に応じて実装）

## 設定項目

### 必須設定
- AI APIキー
- AIサービス選択（OpenAI、Claudeなど）
- デフォルトの保存先フォルダ
- ベクトル化モデル（初回設定時）

### オプション設定
- チャット履歴の保持期間
- 要約のデフォルト詳細度
- Web検索結果の最大取得数
- テーマ設定（ダーク/ライト）
- 通知設定
- ベクトル化対象ディレクトリ（デフォルト：全領域）
  - 除外フォルダの指定（Deny List方式）
  - デフォルト強制除外リスト（隠しファイル・フォルダ）の表示
- ベクトル検索のデフォルト結果件数（デフォルト：10件）
- キーワード検索のデフォルト動作（AND/OR優先）
- ベクトル化キューの同時実行数（デフォルト：2、変更可能）
- ベクトル化のリトライ回数（デフォルト：3〜5回、変更可能）
- インデックス更新のデバウンス時間（デフォルト：数秒）
- インデックスの再構築機能（「Rebuild Index」ボタン）

## 今後の拡張機能（将来の検討事項）

- カスタムプロンプトテンプレートの作成・保存
- 複数のAIサービスを同時に使用する機能
- チャット履歴のエクスポート/インポート
- プラグイン間連携機能

## 検索機能の検討事項・未確定事項

以下の点について、実装前に詳細を決定する必要があります：

### 1. 日本語解析の実装詳細
- **決定事項**: Obsidianは日本語解析のための公式APIをプラグイン向けに公開していない
- **実装方針**: 
  - **推奨方法**: `Intl.Segmenter`（ブラウザ標準API）を使用
    - メリット: ライブラリ不要、超高速、メモリ消費小、Obsidianのデスクトップ・モバイル版で利用可能
    - デメリット: 品詞情報（名詞、動詞など）は取得不可。単語の区切りのみ取得可能
    - 用途: キーワード検索の単語分割、ハイライト表示
  - **代替方法**: 品詞情報が必要な場合のみ外部ライブラリを検討
    - **TinySegmenter**: バランス型（約25KB、簡易的な品詞情報）
    - **Kuromoji.js**: 高精度型（10MB以上の辞書、詳細な品詞・読み仮名）
- **選定基準**: 
  - キーワード検索の単語分割のみが必要 → `Intl.Segmenter`を使用
  - 名詞抽出などの品詞フィルタリングが必要 → `TinySegmenter`を検討
  - 高精度な品詞解析や読み仮名が必要 → `Kuromoji.js`を検討（ただしプラグインサイズ肥大化に注意）

### 2. ベクトル化キューの詳細仕様
- **決定事項**: Obsidianプラグイン環境（ローカル動作のElectronアプリ）特有の制約を考慮した設計

#### 2.1 同時実行数の上限
- **設定**: 最大2スレッド（FIFO方式）
- **理由**:
  - APIレート制限（429 Too Many Requests）を回避
  - ユーザーのネットワーク帯域を占有しない
  - UIへの影響を最小化
- **実装**: セマフォまたは`p-limit`ライブラリを使用して同時実行数を制御

#### 2.2 エラーハンドリングとリトライロジック
- **リトライ戦略**: Exponential Backoff（指数バックオフ）
  - APIエラー（5xx系、429）の場合：1秒後、2秒後、4秒後...と待機時間を伸ばして再試行
  - 最大リトライ回数：3〜5回で諦めて「失敗ステータス」にしてスキップ
- **致命的なエラー（401 Unauthorizedなど）**:
  - APIキー無効などは即時停止し、ユーザーに通知（Notice）を出してキュー全体を一時停止（Pause）

#### 2.3 キューの優先順位
- **設計**: 2段階の優先度（High/Low）
  - **High Priority（即時）**: ユーザーが現在編集・保存したファイル（`on('modify')` イベント）
  - **Low Priority（バックグラウンド）**: プラグイン起動時の全ファイルスキャンや、Vault全体のリインデックス
- **処理順序**: FIFO方式だが、High優先度のタスクが発生したらLow優先度のタスクより先に処理
- **実装**: 優先度付きキューまたは2つのキューを管理

#### 2.4 キューの永続化（プラグイン再起動時の復元）
- **保存場所**:
  - **小規模**: `data.json`（プラグイン設定ファイル）にキューの状態（ファイルパス、リトライ回数）を保存
  - **大規模**: 何万ファイルもある場合、`data.json`の頻繁な書き込みはパフォーマンス低下を招くため、**IndexedDB**（`localforage`ライブラリ推奨）の使用を検討
- **復元ロジック**:
  - `onload()`時に保存されたキューを読み込み
  - 処理開始前に`this.app.vault.getAbstractFileByPath()`でファイルの存在確認を行う（外部エディタやGit同期でファイルが削除されている可能性があるため）

#### 2.5 進捗表示方法（UI）
- **ステータスバー（右下）**:
  - 基本はここ。「Vectorizing: 5/100」のように表示
  - クリックで詳細モーダルを表示したり、一時停止/再開をトグルできるようにする
- **Notice（トースト通知）**:
  - 「完了しました」「エラーで停止しました」など、イベントの区切りでのみ使用（1ファイルごとに出すと通知が溢れるため避ける）
- **設定画面/専用View**:
  - 失敗したファイルの一覧や、手動での再実行ボタンを配置

### 3. ベクトルデータの保存形式と場所
- **決定事項**: Obsidian（ローカル環境）とOrama（インメモリ・エッジ指向検索エンジン）を組み合わせる場合、「ローカルファースト」かつ「メモリ効率」を最優先に設計

#### 3.1 保存形式
- **推奨形式**: バイナリ形式（dpack / Protocol Buffers等）
- **理由**: 
  - JSONは可読性があるが、ベクトルデータ（浮動小数点の配列）を含むとファイルサイズが肥大化し、パース（読み込み）速度が遅くなる
  - Oramaの公式プラグイン（`@orama/plugin-data-persistence`）などは、JSONより効率的なバイナリ形式（dpackなど）をサポート
- **実装**: OramaのPersistence Pluginを使用

#### 3.2 保存場所
- **保存先**: `.obsidian/plugins/プラグインID/` 配下
- **具体的なパス**: `vault_root/.obsidian/plugins/your-plugin-id/index-data.bin`
- **理由**: 
  - Obsidianの作法として、プラグイン固有のデータはこのディレクトリに置くのが基本
  - ユーザーのMarkdownファイル（Vaultのルート）を汚さない

#### 3.3 データベースサイズの見積もりと最適化
- **サイズの見積もり（概算）**
  - **計算式**: `ノート数 × チャンク数 × 次元数 × 4バイト(Float32)`
  - **例（1,000ノート、1536次元の場合）**:
    - 1ノートあたり平均2チャンクと仮定 = 2,000ベクトル
    - 2,000 × 1,536 × 4 bytes ≈ **約12MB**
    - これにOramaのインデックス構造（メタデータや検索用グラフ）のオーバーヘッドが加わる
    - 数万ノートになると数百MBになり、初期ロードに時間がかかる
- **最適化戦略**
  - **次元削減**: ローカルLLM（例: `all-MiniLM-L6-v2`）を使用すれば384次元で済み、サイズは1/4になる
  - **量子化（Quantization）**: Float32（32ビット）ではなく、Int8（8ビット）やバイナリ量子化を検討。精度は落ちるがサイズは劇的に減る
  - **メモリ使用量の注意**: ノート数が多い（1万〜）とOramaがメモリを食いつぶす可能性がある

#### 3.4 インデックスの更新頻度とタイミング
- **タイミング**: `modify`イベント + デバウンス（Debounce）
  - ユーザーが入力を止めてから数秒後、または明示的に保存されたタイミングで更新処理を実行
  - リアルタイム更新は重いので避ける
- **処理内容**: 
  - 該当ファイルの古いベクトルを削除
  - 新しいテキストでEmbeddingし直し、再登録（Oramaはドキュメント単位のCRUDが可能）
- **初期構築（First Load）**
  - プラグイン起動時にディスクからインデックスをロード
  - ロードしたインデックスの最終更新日時より新しいMarkdownファイルがあれば、バックグラウンドで差分更新を実行

#### 3.5 データのバックアップと復元方法
- **バックアップ戦略**: 「バックアップ不要（または除外）」が基本
  - ベクトルデータはいつでもMarkdownから再生成（Rebuild）可能
  - ベクトルインデックスはあくまで「生成物（キャッシュ）」であるという考え方
- **同期ツールとの扱い**:
  - Obsidian Sync / iCloud / Dropbox等の同期ツールは、頻繁に書き換わる巨大なバイナリファイルの同期を苦手とする（コンフリクトの原因や帯域の無駄）
  - **推奨**: インデックス保存ファイル（`.bin`等）を同期対象外にする設定をユーザーに案内するか、同期されないフォルダにキャッシュを置く設計
- **復元方法**:
  - インデックスファイルが破損したり消失した場合は、全ファイルを再スキャンしてEmbeddingし直す「Rebuild Index」ボタンをUIに用意

### 4. 検索結果のカードUI詳細
- **決定事項**: シンプルで実用的、かつ「検索の目的（＝探している情報を見つける）」に集中した構成。幅広のカード（実質的なリストビュー）で、視線の移動が縦方向だけで済むため、スキャン性が高い設計。

#### 4.1 カードサイズとレイアウト
- **レイアウト**: 幅広のカード（実質的なリストビュー）
- **サイズ**: 親コンテナにパディング（`padding: 0 8px;`など）を設定し、カード自体は`width: 100%;`にする
- **理由**: 99%だと1%の隙間が左右どちらかに寄ってしまうのを防ぎ、均等な余白を作れるため
- **スタイリング**: 
  - カード全体に`padding: 12px;`を設定
  - カード間に`border-bottom: 1px solid #e0e0e0;`で区切り線を表示
  - `cursor: pointer;`でクリック可能であることを示す

#### 4.2 プレビュー表示の実装
- **行数**: 3行で固定
- **実装方法**: CSSの`line-clamp`を使用
  ```css
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
  ```
- **スタイリング**: 
  - フォントサイズ: `0.9em`
  - 行間: `line-height: 1.5`
  - 色: `#555`（読みやすさを重視）

#### 4.3 メタデータの表示項目と優先順位
- **ヘッダー行（1行目）の構成**:
  - **左側**: ファイル名（太字、`font-size: 1.1em`）
  - **中央**: パンくずリスト（Short path）または親フォルダ名（`font-size: 0.8em`、色: `#888`）
    - 例: `.../ProjectA/Design/`（階層が深い場合）
    - 理由: ディレクトリルートだけだと階層が深い場合に文脈が失われるため
  - **右側**: 最終更新日（`font-size: 0.8em`、色: `#888`）
    - 理由: 「いつ書いたか」は情報の有効性を判断する重要なファクター
- **レイアウト**: `display: flex; justify-content: space-between;`で左右に配置
- **ボディ行（2-4行目）**: プレビューテキスト（3行制限）

#### 4.4 インタラクション
- **クリック動作**: カード全体がクリック可能
  - 2画面構成の場合：左側で閲覧中なら右側で開く
  - それ以外：別タブで開く
- **ホバー効果**: マウスオーバー時に背景色を変更してクリック可能であることを示す（オプション）

#### 4.5 モバイル対応
- **考慮事項**: デスクトップでの情報密度を重視する設計
- **モバイルでの表示**: 必要に応じて、カードのレイアウトを縦方向に調整（メタデータを縦に積むなど） 

### 5. RRFアルゴリズムのパラメータ
- **決定事項**: RRF（Reciprocal Rank Fusion）を採用する場合、スコアの絶対値ではなく「順位（ランク）」だけを見て統合するため、「正規化の悩みから解放される」のが最大のメリット

#### 5.1 RRFの定数k（デフォルト60）の設定
- **設定値**: **k=60で固定**
- **理由**: 
  - 論文の推奨値であり、Elasticsearchなどのデフォルトもこれ
  - 検索結果の「外れ値（片方だけで偶然1位になったノイズ）」を排除するのに最もバランスが良い
  - 上位の順位差によるスコアの減衰が緩やかになり、「キーワード検索で10位、ベクトル検索で5位」のような「両方でそこそこ上位」の文書が総合1位になりやすい
- **計算式**: 
  $$RRFscore(d) = \sum_{r \in R} \frac{1}{k + rank(d)}$$
  - ここでのkは、「上位ランクの文書をどれだけ極端に優遇するか」を緩和（スムージング）するためのパラメータ

#### 5.2 キーワード検索とベクトル検索の重み付け比率
- **初期設定**: **重み付けなし（1:1）**でスタート
- **理由**: 
  - ハイブリッド検索の強みは「互いの弱点の補完」にあるため、どちらかに偏らせるとそのメリットが薄れることが多い
- **将来的な拡張**: クエリ分析に基づく自動調整を検討
  - クエリが「数字とアルファベットのみ（型番っぽい）」→ キーワード検索を重視
  - クエリが「〜の方法（文章）」→ ベクトル検索を重視
- **重み付けの計算式（将来の拡張用）**:
  $$FinalScore = W_{key} \times RRF_{key} + W_{vec} \times RRF_{vec}$$

#### 5.3 ユーザー調整可否 vs 固定値
- **決定**: **ユーザーには触らせず、固定（または内部ロジックで自動調整）にする**
- **理由**: 
  - エンドユーザーは「キーワード検索とベクトル検索の違い」を直感的に理解できない
  - 「スライダーをいじったら求めているものが出なくなった」という体験を招きやすい
- **代替案（UIでの見せ方）**: もし調整させたいなら、パラメータそのものではなく「検索モード」として提供
  - 「型番・完全一致モード」→ 裏側でキーワード検索比率を上げる
  - 「あいまい検索モード」→ 裏側でベクトル比率を上げる

#### 5.4 検索方式ごとのスコア正規化方法
- **決定**: **RRFを使うなら、事前のスコア正規化は「不要」**
- **理由**: 
  - これがRRFの最大の発明。BM25スコア（上限なし）とコサイン類似度（0.0〜1.0）を混ぜる際、本来なら`Min-Max Scaling`などが必要だが、RRFは「順位」という共通の指標に変換してしまうため、スコアのスケールを気にする必要がない
  - 各検索エンジンから`TOP N`件のIDと順位だけを取得すれば計算可能

#### 5.5 実装方針
- **パラメータ**: k=60で固定
- **重み付け**: 1:1で実装（重み付けなし）
- **ユーザー調整**: なし（固定）
- **正規化**: 何もしない（順位だけ取得する）
- **将来的な拡張**: クエリ分析に基づく自動調整ロジックを検討

### 6. ベクトル化済みマークの表示方法
- **決定事項**: ObsidianのAPIを使用すれば、既存のページ（エディタ画面）の特定位置にマークやアイコンを追加することが可能

#### 6.1 実装パターンの比較
- **パターン1: ビューヘッダーのアクションアイコン (View Header Action)** - **推奨**
  - **表示位置**: エディタ右上のタイトルバー（「リンクをコピー」などが並んでいる場所）のアイコン列
  - **実装方法**: Obsidian APIの`view.addAction`を使用
  - **メリット**: APIとして用意されており実装が簡単、違和感なく馴染む
  - **デメリット**: 基本は「ボタン」としての挙動なので、単なるステータス表示にするには少し工夫（クリック無効化やCSS調整）が必要
- **パターン2: ビューへのCSSクラス付与 (View Container Class)**
  - **表示位置**: 自由。CSSで「右上に`position: absolute`」でバッジを浮かせたり、タイトルの横にチェックマークを出したりできる
  - **実装方法**: エディタのコンテナ自体に`vectorized`などのクラスを付与し、CSSで表示
  - **メリット**: 「ボタン」ではなく純粋な「表示」として実装できる、視認性が高い
  - **デメリット**: DOM要素を直接操作する感覚に近いため、テーマとの競合を少し気にする必要がある
- **パターン3: ファイルエクスプローラーの装飾 (File Decoration)**
  - **表示位置**: 左側のファイルリストのファイル名の横
  - **メリット**: 「ファイルを開く前」にベクトル化済みかどうかがわかる
  - **デメリット**: 開いているページ内での主張は弱い（タブのタイトル横には出る）

#### 6.2 推奨実装案
- **採用パターン**: パターン1（アイコン）+ パターン2（色）の組み合わせ
- **実装方法**:
  - Obsidian APIの`addAction`を使いつつ、CSSで色をつけて「状態」を表す
  - `active-leaf-change`（タブ切り替え時）や`metadata-change`（ファイル保存・メタデータ変更時）のイベントをフックにして、その都度「DBに登録済みか？」を判定し、アイコンの追加・削除を行う
- **デザイン**:
  - **アイコン**: `check-circle`（チェックマーク）や`database`（DBマーク）など（Obsidian標準のLucide iconsを使用）
  - **色**: CSSクラスを追加して緑色（成功色）や青色にすることで「完了済み」を表現
  - **ツールチップ**: 「Vectorized」などのテキストを表示
- **CSS実装**:
  ```css
  /* ベクトル化済みアイコンを緑色にする */
  .view-header .view-action.is-vectorized-icon {
      color: var(--color-green);
      opacity: 1; /* 通常は薄いグレーなので、強調する場合は不透明度を上げる */
      cursor: default; /* ボタンっぽさを消す場合 */
  }
  ```

#### 6.3 判定ロジック
- **判定方法**: 
  - フロントマターに`vectorized: true`があるか、またはDB上のIDリストと照合して判定
  - ベクトル化が完了した時点で、ファイルのメタデータまたはDBに登録済みフラグを設定
- **更新タイミング**:
  - タブ切り替え時（`active-leaf-change`イベント）
  - ファイル保存・メタデータ変更時（`metadata-change`イベント）
  - ベクトル化完了時

#### 6.4 表示/非表示の制御
- **自動制御**: 判定ロジックに基づいて自動的にアイコンの追加・削除を行う
- **設定による制御**: 必要に応じて、設定画面でマークの表示/非表示を切り替え可能にする（オプション）

### 7. ディレクトリ指定UI
- **決定事項**: 独自モーダルUI & DB保存による実装。複数ディレクトリ選択と除外機能を提供し、AIのコスト戦略（トークン節約・ノイズ除去）を実現

#### 7.1 UI形式
- **実装方法**: 独自モーダルUI（ReactやSvelte等でチェックボックス付きのツリービューを自作）
- **理由**: 
  - Obsidian標準の「フォルダ選択」は通常、単一選択（ファイルの移動先指定など）を想定
  - 「複数選択」かつ「除外設定」という複雑なステータスを管理するには、標準UIの流用は困難
  - VS Codeのファイルエクスプローラーのような見た目のツリービューがベストプラクティス

#### 7.2 複数ディレクトリ選択と除外機能
- **機能**: 複数ディレクトリの選択と除外をサポート
- **理由**: 
  - **コスト削減**: `Templates/`, `Daily Notes/`（の古いログ）, `Archives/`など、ベクトル化の意味がない（あるいは検索ノイズになる）フォルダは必ず存在
  - これらを弾くことで、Embeddingのコストと検索精度が劇的に改善
- **方式**: Deny List（除外方式）を採用
  - 初期設定は全域（Allow List方式）
  - ユーザーが明示的に除外フォルダを指定する方式
  - UI上で「基本は全域だが、特定のみ除外」という自然な操作感

#### 7.3 初期設定
- **設定**: 初期設定は「全域」（ルートディレクトリ全体）
- **理由**: 導入時のハードルを下げる（ゼロコンフィグで動く）ため
- **注意点**: 
  - 数千ファイルある保管庫でいきなり全域ベクトル化が始まると、APIコストやCPU負荷が急増する可能性
  - **安全策**: 「初回インデックス作成前に確認ダイアログを出す」か「デフォルトでは読み込みを一時停止しておく」

#### 7.4 データ構造の保存
- **設定（パス情報）**: `data.json` (`plugin.saveData()`)
  - 単なるパスの文字列配列（例: `excludedFolders: ["Templates", "System/Logs"]`）として保存
  - 軽量で管理しやすい
- **インデックス（ベクトルデータ）**: IndexedDB / SQLite / Vector DB
  - こちらはベクトルそのものを保存する場所

#### 7.5 フォルダ名の変更・移動への追従
- **課題**: 設定で`Projects/A`を指定していたのに、ユーザーが`Work/A`にリネームした場合、設定がリンク切れを起こす
- **対策**:
  - **簡易案**: 文字列として保存し、存在しないパスは無視する（UI上で「見つかりません」と警告を出す）
  - **高度な案**: Obsidianの`vault.on('rename')`イベントを監視し、設定ファイル内のパス文字列も自動的に書き換える

#### 7.6 具体的なUIイメージ
- **3値ステータス**を持つツリーUIを実装
  - **対象**: チェックボックスが`[v]`の状態、以下のファイルを含める
  - **除外**: チェックボックスが`[ ]`の状態、明示的に除外（コストカット）
  - **継承**: 親設定を継承（親が対象なら対象、親が除外なら除外）
- **表示例**:
  ```
  📂 Root [v] 対象
   ├─📂 Daily [ ] 除外
   ├─📂 Projects [v] 対象
   └─📂 Templates [ ] 除外
  ```

#### 7.7 デフォルト強制除外リスト
- **機能**: 隠しファイル・フォルダ（`.`で始まるもの）をデフォルトで強制除外
- **対象例**: 
  - `.obsidian`（Obsidianの設定フォルダ）
  - その他の隠しファイル・フォルダ
- **理由**: 設定ファイル自体をベクトル化してしまい、ノイズになる可能性があるため
- **実装**: 設定UI上で「強制除外」として表示し、ユーザーが変更できないようにする（または警告を表示）

### 8. モデル変更時の警告UI
- **決定事項**: モデル変更は「不可逆的」かつ「高コスト（時間・金銭）」な操作のため、ユーザーが後悔しないよう、親切かつ慎重なUI設計が必要

#### 8.1 警告ダイアログと確認フローの設計
- **基本方針**: 単なる「OK/Cancel」ではなく、「何が起きるか」を認識させるデザイン
- **UI構成要素**:
  - **インパクトの可視化**: 「モデルA → モデルB」への変更によって何が変わるかを表示
    - 例: 「精度は向上しますが、処理速度は0.5秒遅くなります」
    - 例: 「過去のチャット履歴との整合性が失われる可能性があります」
  - **「破壊的変更」の明示**: GitHubのリポジトリ削除時のようなフリクション（あえて手間をかけさせる仕組み）を導入
    - チェックボックス：「既存のインデックスデータが削除されることを理解しました」
    - 入力確認：「確認のために『変更』と入力してください」（オプション）
- **フロー**:
  1. モデル選択のプルダウンを変更
  2. **インパクト分析モーダル**を表示（即座に変更しない）
  3. コスト・時間の見積もりを表示
  4. リスク確認のチェックボックスにチェックを入れる
  5. 「変更して再計算を開始」ボタンが活性化（Active）する

#### 8.2 既存データの削除確認と戦略
- **基本方針**: 「削除しますか？」と聞くだけでなく、「いつ消すか」の選択肢を与える
- **推奨**: 「即時削除」は極力避ける（モデル変更後に「やっぱり前の方が良かった」となるケースが多いため）
- **3つのパターン**:
  - **A. スナップショット保持（推奨）**:
    - 「古いモデルの計算結果（インデックスなど）」を一時的に保持しておく
    - UI: 「移行期間として7日間データを保持しますか？（ストレージコスト: +XX円）」
  - **B. 遅延削除（Lazy Deletion）**:
    - 新しいモデルでの再計算が完了し、正常稼働を確認するまで古いデータを消さない
  - **C. 完全置換**:
    - コスト重視の場合。警告文を赤字で強調し、元に戻せないことを強く伝える

#### 8.3 再計算のコスト見積もり表示
- **表示すべき3つの数字**:
  1. **所要時間**: 「完了まで約 XX 分かかります」
  2. **金銭的コスト**（API利用料などが発生する場合）: 「この再計算には約 $X.XX かかります」
  3. **システム負荷/ダウンタイム**: 「処理中は検索機能が利用できません」または「バックグラウンドで処理するため利用可能です」
- **UI表現**:
  - メーターやプログレスバーの予測表示
  - 「現在 10,000 件のデータがあります。再計算レートは 50件/秒 です」といった根拠の提示
- **表示内容の例**:
  - 既存の検索用インデックス：XX件
  - 再計算の推定コスト：約 $X.XX
  - 推定所要時間：約 XX分

#### 8.4 段階的な移行オプション（マイグレーション戦略）
- **基本方針**: 「一括変換」はリスクが高いため、システムの特性に合わせて以下のオプションをUIで選ばせる
- **オプションA：オンデマンド移行（Lazy Migration）**
  - **概要**: 全データを今すぐ再計算せず、ユーザーがそのデータにアクセスした瞬間に新しいモデルで計算し直す
  - **メリット**: 初期コストがゼロ、待ち時間なし
  - **デメリット**: 初回アクセス時にラグが発生する
- **オプションB：バックグラウンド移行（低負荷モード）** - **推奨**
  - **概要**: システムを利用可能な状態にしたまま、裏で少しずつ再計算する
  - **UI**: 「バックグラウンドで更新する（完了まで時間がかかりますが、操作は可能です）」
  - **メリット**: システムを利用しながら移行できる
- **オプションC：メンテナンスモード（一括更新）**
  - **概要**: システムをロックして最速で終わらせる
  - **メリット**: 最短時間で完了
  - **デメリット**: 処理中は検索機能が利用できない

#### 8.5 UIワイヤーフレームのイメージ
- **ダイアログ構成**:
  ```
  [ダイアログ] モデルを "GPT-3.5" から "GPT-4" に変更します
  
  ⚠️ 注意: この操作は過去の埋め込みベクトルデータに影響します。
  
  ■ 変更の影響
  ・ 既存の検索用インデックス：15,400件
  ・ 再計算の推定コスト：約 $5.00
  ・ 推定所要時間：約 20分
  
  ■ 移行オプション
  (●) バックグラウンドで更新 (操作を続けられます)
  ( ) 今すぐ更新 (完了まで検索機能が停止します)
  
  ■ データ保持
  [v] 旧データを3日間保持する（問題があった場合に即座に戻せます）
  
  [ キャンセル ]   [ 変更を開始する ]
  ```

### 9. Web Workerの実装詳細
- **決定事項**: Web Workerを利用したOrama（クライアントサイド検索エンジン）の運用とAPI呼び出しの設計により、UIのメインスレッドをブロックさせない（＝サクサク動く）アプリケーションを実現

#### 9.1 OramaのWorker環境での動作確認
- **結論**: **OramaはWeb Workerで完璧に動作する**（Orama公式も推奨する構成の一つ）
- **アーキテクチャ**:
  - **インデックスの保持**: Oramaのインスタンス（インデックスデータ）は**Worker内だけで保持**する
  - **メインスレッドへの転送禁止**: メインスレッドにインデックス全体を渡してはいけない（メモリと転送コストの無駄）
  - **操作**: メインスレッドからは「検索クエリ」や「追加したいドキュメント」だけを送り、Workerからは「検索結果（IDやスニペット）」だけを受け取る

#### 9.2 OpenRouter API呼び出し: Worker vs メインスレッド
- **結論**: **Worker内で実行することを強く推奨**
- **メインスレッド実行のデメリット**:
  - LLMからのレスポンスはストリーミング（Server-Sent Events）で返ってくることが多い
  - これをパースしてテキスト結合し、さらにOramaにベクトル化して保存...という処理をメインスレッドで行うと、**UIの描画（入力フォームの反応やアニメーション）がカクつく原因**になる
- **Worker実行のメリット**:
  - **バックグラウンド処理**: データの受信、パース、Oramaへのインデックス登録までをWorker内で完結させれば、メインスレッドは「完了通知」を受け取るだけで済む
  - **制約事項**: Worker内ではDOMにアクセスできないが、API呼び出し（`fetch`）は問題なく行える

#### 9.3 Workerとメインスレッド間のデータ転送の最適化
- **構造化複製アルゴリズム（Structured Clone Algorithm）のコスト**:
  - Workerへのデータ転送は「参照渡し」ではなく「コピー」
  - 巨大なJSONオブジェクトを頻繁に送ると、シリアライズ/デシリアライズのコストが発生
- **対策**:
  1. **必要なデータだけを送る**: 検索結果としてドキュメント全体を返すのではなく、リスト表示に必要なフィールド（タイトル、ID、要約）だけを返すようにOramaの`returning`オプションなどを活用
  2. **Transferable Objects (ArrayBuffer) の検討**: もし画像データや巨大なバイナリを扱う場合は`Transferable Objects`を使えばゼロコピー転送が可能（通常のJSONテキストであればそこまで気にする必要はない）
  3. **状態を持たせない**: メインスレッド側で巨大なデータを持たず、データの実体（State）はWorkerが正（Master）であるという設計にする

#### 9.4 推奨アーキテクチャ
- **処理フロー**:
  1. メインスレッド（UI）: ユーザー入力を受け取る
  2. Web Worker: 検索クエリや追加したいドキュメントを受け取る
  3. Web Worker: OpenRouter APIを呼び出し（ストリーミング対応）
  4. Web Worker: テキスト解析 & 蓄積（ストリーミング処理）
  5. Web Worker: 完了したテキストをEmbedding & Oramaにインデックス登録
  6. Web Worker: メインスレッドに処理完了通知 & 更新された関連情報の提示
- **途中経過の表示**: ストリーミング中に途中経過を表示したい場合のみ、メインスレッドに転送

#### 9.5 実装のポイント
- **イベントリスナーの管理**: Web Workerの記述はイベントリスナーが複雑になりがちなので、**Comlink**などのライブラリを使うか、アクションベースで分岐させるのが定石
- **メッセージタイプ**: `INIT_DB`, `ADD_DOCUMENT_FROM_API`, `SEARCH`などのアクションベースで分岐
- **エラーハンドリング**: Worker内でエラーが発生した場合、メインスレッドにエラー通知を送る
- **初期化**: Worker起動時に`INIT_DB`メッセージでOramaのインスタンスを初期化

### 10. ファイル変更の監視とインデックス更新
- **決定事項**: Obsidianの`Vault`イベントを利用し、UIをブロックしない「非同期キュー」での処理が鉄則

#### 10.1 検知方法
- **実装**: `this.app.vault.on()`を利用
- **イベントタイプと対応処理**:
  - **`modify`**: ファイル内容の変更。再ベクトル化とインデックス更新（`update`）が必要
  - **`create`**: 新規作成。インデックス追加（`insert`）が必要
  - **`delete`**: 削除。インデックス削除（`remove`）が必要
  - **`rename`**: パス変更。IDをパスにしている場合、旧パスで削除→新パスで追加が必要

#### 10.2 更新タイミング（推奨: デバウンス + キュー）
- **基本方針**: ユーザーがタイプするたびに実行すると負荷が高すぎるため、デバウンスとキューを組み合わせる
- **Debounce**: 最後の入力から数秒（例: 2〜5秒）待ってから処理キューに入れる
- **Queue**: Web Workerに順次タスクを投げ、メインスレッドを阻害しないようにする

#### 10.3 削除対応
- **処理**: ファイル削除イベント時、即座にOramaのインデックスから該当ID（ファイルパス）を削除
- **理由**: これが残ると「検索結果に出るのにファイルがない」エラーになる

### 11. エラーハンドリングとリカバリー
- **決定事項**: ローカル処理であるため、システム全体のクラッシュを防ぐ「部分失敗の許容」が重要

#### 11.1 ベクトル化失敗時の処理
- **基本方針**: 特定のファイルで失敗しても、ループを止めず`console.warn`でログを残し、次のファイルへ進む
- **失敗ファイルの管理**: 失敗したファイルリストを内部ステートに保持し、設定画面等で「未インデックスのファイル: 3件（再試行）」のように表示するのが親切

#### 11.2 DB破損時の復旧
- **基本方針**: ローカルDB（IndexedDB等）が破損した場合、整合性を取るコストをかけるより**「インデックスの全再構築（Rebuild）」**機能を提供するのが最も確実
- **理由**: 元データ（Markdown）は常に正として存在するため

#### 11.3 ユーザー通知
- **バックグラウンド処理**: 見えないため、ステータスバー（右下）に「Indexing: 5/100...」のような進捗アイコンを出すのがベストプラクティス
- **Notice（トースト通知）**: 致命的なエラー以外で連発するのは避ける

### 12. パフォーマンス最適化
- **決定事項**: 数千ファイル規模になると、検索そのものより「埋め込み生成（Embedding）」と「初期ロード」がボトルネックになる

#### 12.1 段階的ロード
- **基本方針**: プラグイン起動時に巨大なインデックスを一気にメモリ展開するとフリーズする
- **実装**: Oramaはインメモリが基本だが、永続化データの読み込みは非同期で行い、検索可能になるまで「準備中」ステータスにする

#### 12.2 ページネーション
- **基本方針**: 検索結果はトップ10〜20件のみ表示し、DOMの要素数を抑える
- **実装方法**:
  - スクロールに応じて追加レンダリング（Infinite Scroll）
  - または「もっと見る」ボタンで対応

#### 12.3 キャッシュ戦略
- **必須**: 生成したベクトルデータはIndexedDB等に永続化する。起動のたびに全ファイルベクトル化するとバッテリーとCPUを浪費する
- **最適化**: ファイルの`mtime`（最終更新日時）をハッシュとして保存し、変更がないファイルはベクトル生成をスキップしてキャッシュを利用する

### 13. モバイル対応
- **決定事項**: 最もハードルが高い部分。PCと同じ動作は保証できない前提で設計する

#### 13.1 Web Worker
- **必須**: メインスレッドでベクトル計算を行うと、モバイルでは入力遅延が顕著に発生し、OSによってアプリがキルされる可能性がある

#### 13.2 メモリとモデルの制約
- **メモリ制限**: モバイル（特にiOS）はブラウザのメモリ制限が厳しい
- **モデル選択**:
  - PCでは高精度なモデル（例: `Xenova/all-MiniLM-L6-v2`）を使う
  - モバイルでは**量子化（Quantized）された軽量モデル**を使用するか、あるいは**モバイルではベクトル生成を行わず、PCで生成したインデックスを同期して「検索（閲覧）のみ」許可する**という割り切りも検討すべき

#### 13.3 Oramaの動作
- **検索自体**: 計算コストは低いが、大規模なJSONデータのロードでクラッシュするリスクがある
- **対策**: モバイル時はインデックス件数に上限を設けるなどのガードが必要になる場合がある

### 14. 依存関係の追加
- **決定事項**: Oramaは開発スピードが速いため、破壊的変更が入ることがある。バージョン管理とバンドルサイズに注意が必要

#### 14.1 Oramaのバージョン
- **バージョン固定**: `package.json`でバージョンを固定（`^`ではなく厳密指定など）し、アップデート時は入念なテストを推奨

#### 14.2 バンドルサイズ
- **Orama本体**: 軽量
- **Transformers.jsとモデルの重みファイル**: 容量を食う
- **対策**:
  - モデルファイルはバンドルに含めず、初回実行時にCDNからダウンロードしてキャッシュする仕組み（Transformers.jsのデフォルト挙動）にする
  - またはプラグインサイズが許容できるなら軽量モデルのみ同梱するか検討が必要

#### 14.3 ライセンス
- **Orama**: Apache 2.0
- **Embeddingモデル**: 使用するEmbeddingモデルのライセンス（MIT, Apache 2.0, OpenRAILなど）も併せて確認し、READMEに記載する

